name: iOS TestFlight

on:
  workflow_dispatch:
  push:
    branches: [ main ]

jobs:
  ios:
    runs-on: macos-14
    timeout-minutes: 60
    env:
      BUNDLE_ID: com.mechanicpart.mechanicPart
      TEAM_ID: 75U4C4C87J
      SCHEME: Runner
      WORKSPACE: ios/Runner.xcworkspace

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Install Flutter
        uses: subosito/flutter-action@v2
        with:
          flutter-version: '3.35.7'
          cache: true

      - name: Flutter build (unsigned)
        run: |
          flutter doctor -v
          flutter pub get
          flutter build ios --release --no-codesign

      - name: Ensure CocoaPods deps
        run: |
          cd ios
          pod install

      - name: Decode and validate P12
        env:
          IOS_CERT_P12_BASE64: ${{ secrets.IOS_CERT_P12_BASE64 }}
          IOS_CERT_P12_PASSWORD: ${{ secrets.IOS_CERT_P12_PASSWORD }}
        run: |
          # Cross-platform decode (GNU base64 -d or BSD base64 -D)
          printf "%s" "$IOS_CERT_P12_BASE64" | base64 -d > /tmp/signing.p12 2>/dev/null || \
          printf "%s" "$IOS_CERT_P12_BASE64" | base64 -D > /tmp/signing.p12
          if [ ! -s /tmp/signing.p12 ]; then echo "Decoded P12 is empty; check IOS_CERT_P12_BASE64" >&2; exit 1; fi
          # Trim CR/LF from password (Windows copy can add CR; ensure no newline)
          P12_PASS=$(printf "%s" "$IOS_CERT_P12_PASSWORD" | tr -d '\r\n')
          # Validate password quietly
          if ! /usr/bin/openssl pkcs12 -in /tmp/signing.p12 -passin pass:"$P12_PASS" -info -noout >/dev/null 2>&1; then
            echo "P12 password validation failed. Update IOS_CERT_P12_PASSWORD to match the exported .p12." >&2
            exit 1
          fi
          # Optional: show cert label/subject to confirm correct file (no private key output)
          /usr/bin/openssl pkcs12 -in /tmp/signing.p12 -passin pass:"$P12_PASS" -nokeys -clcerts 2>/dev/null | \
            /usr/bin/awk '/friendlyName|subject/ {print}' || true

      - name: Create keychain and import cert
        env:
          IOS_CERT_P12_PASSWORD: ${{ secrets.IOS_CERT_P12_PASSWORD }}
        run: |
          set -euo pipefail
          KEYCHAIN_NAME=build.keychain
          KEYCHAIN_PASSWORD="temp_keychain_pass"
          security create-keychain -p "$KEYCHAIN_PASSWORD" "$KEYCHAIN_NAME"
          security set-keychain-settings -lut 21600 "$KEYCHAIN_NAME"
          security unlock-keychain -p "$KEYCHAIN_PASSWORD" "$KEYCHAIN_NAME"
          # Import certificate into custom keychain (capture exit code despite set -e)
          P12_PASS=$(printf "%s" "$IOS_CERT_P12_PASSWORD" | tr -d '\r\n')
          set +e
          security import /tmp/signing.p12 -k "$KEYCHAIN_NAME" -f pkcs12 -P "$P12_PASS" -A -T /usr/bin/codesign -T /usr/bin/security
          IMPORT_RC=$?
          set -e
          if [ "$IMPORT_RC" -ne 0 ]; then
            echo "PKCS12 import failed; falling back to PEM import" >&2
            # Extract unencrypted private key and certificate from P12
            openssl pkcs12 -in /tmp/signing.p12 -passin pass:"$P12_PASS" -nocerts -nodes -out /tmp/key.pem
            openssl pkcs12 -in /tmp/signing.p12 -passin pass:"$P12_PASS" -clcerts -nokeys -out /tmp/cert.pem
            # Import key first, then certificate
            security import /tmp/key.pem -k "$KEYCHAIN_NAME" -A -T /usr/bin/codesign -T /usr/bin/security
            security import /tmp/cert.pem -k "$KEYCHAIN_NAME" -A -T /usr/bin/codesign -T /usr/bin/security
          fi
          # Allow codesign access to keys in this keychain
          security set-key-partition-list -S apple-tool:,apple: -s -k "$KEYCHAIN_PASSWORD" "$KEYCHAIN_NAME"
          # Make custom keychain the default and in search list
          security list-keychains -d user -s "$KEYCHAIN_NAME" login.keychain
          security default-keychain -s "$KEYCHAIN_NAME"
          # Show available code signing identities
          security find-identity -v -p codesigning || true
          if ! security find-identity -v -p codesigning | grep -q "Apple Distribution"; then
            echo "ERROR: No 'Apple Distribution' identity available. Export the Apple Distribution .p12 (with private key) and update secrets." >&2
            exit 1
          fi
          # Expose keychain path for xcodebuild
          echo "KEYCHAIN_PATH=$HOME/Library/Keychains/${KEYCHAIN_NAME}-db" >> "$GITHUB_ENV"
          echo "KEYCHAIN_PASSWORD=$KEYCHAIN_PASSWORD" >> "$GITHUB_ENV"

      - name: Install provisioning profile (from secret)
        env:
          IOS_PROFILE_BASE64: ${{ secrets.IOS_PROFILE_BASE64 }}
        run: |
          set -euo pipefail
          PP_DIR="$HOME/Library/MobileDevice/Provisioning Profiles"
          mkdir -p "$PP_DIR"
          PROFILE_PATH="$PP_DIR/AppStore.mobileprovision"
          # Decode base64 (GNU -d or BSD -D)
          printf "%s" "$IOS_PROFILE_BASE64" | base64 -d > "$PROFILE_PATH" 2>/dev/null || \
          printf "%s" "$IOS_PROFILE_BASE64" | base64 -D > "$PROFILE_PATH"
          if [ ! -s "$PROFILE_PATH" ]; then
            echo "ERROR: Decoded profile is empty; ensure IOS_PROFILE_BASE64 is set to the base64 of the .mobileprovision" >&2
            exit 1
          fi
          # Decode CMS to plist (fallback to extracting embedded plist if needed)
          DECODED_PLIST="/tmp/profile_decoded.plist"
          if ! /usr/bin/security cms -D -i "$PROFILE_PATH" > "$DECODED_PLIST" 2>/dev/null; then
            # Fallback: extract XML plist block from the binary file
            /usr/bin/awk 'BEGIN{f=0} /<plist/{f=1} f{print} /<\/[Pp][Ll][Ii][Ss][Tt]>/ {exit}' "$PROFILE_PATH" > "$DECODED_PLIST" || true
          fi
          if [ ! -s "$DECODED_PLIST" ]; then
            echo "ERROR: Failed to decode provisioning profile" >&2
            exit 1
          fi
          PROFILE_NAME=$(/usr/libexec/PlistBuddy -c 'Print :Name' "$DECODED_PLIST" 2>/dev/null || echo "")
          PROFILE_UUID=$(/usr/libexec/PlistBuddy -c 'Print :UUID' "$DECODED_PLIST" 2>/dev/null || echo "")
          echo "Using provisioning profile: $PROFILE_NAME ($PROFILE_UUID)"
          echo "PROFILE_NAME=$PROFILE_NAME" >> "$GITHUB_ENV"
          echo "PROFILE_UUID=$PROFILE_UUID" >> "$GITHUB_ENV"

      - name: Show signing build settings
        run: |
          xcodebuild -workspace "$WORKSPACE" -scheme "$SCHEME" -configuration Release -sdk iphoneos -destination "generic/platform=iOS" -showBuildSettings \
          | egrep -i "^(\s*CODE_SIGN|\s*PROVISIONING_PROFILE|\s*PROVISIONING_PROFILE_SUPPORTED|\s*PRODUCT_BUNDLE_IDENTIFIER|\s*DEVELOPMENT_TEAM|\s*CODE_SIGN_ENTITLEMENTS)"

      - name: Xcode archive (Manual signing)
        run: |
          set -o pipefail
          xcodebuild \
            -workspace "$WORKSPACE" \
            -scheme "$SCHEME" \
            -configuration Release \
            -sdk iphoneos \
            -destination "generic/platform=iOS" \
            -archivePath build/ios/Runner.xcarchive \
            -resultBundlePath build/ios/ArchiveResult.xcresult \
            CODE_SIGN_STYLE=Manual \
            DEVELOPMENT_TEAM=$TEAM_ID \
            PRODUCT_BUNDLE_IDENTIFIER=$BUNDLE_ID \
            PROVISIONING_PROFILE_SPECIFIER="$PROFILE_NAME" \
            PROVISIONING_PROFILE="$PROFILE_UUID" \
            PROVISIONING_PROFILE_SUPPORTED=YES \
            OTHER_CODE_SIGN_FLAGS="--keychain,$KEYCHAIN_PATH" \
            CODE_SIGN_IDENTITY="Apple Distribution" \
            archive | tee build/ios/archive.log

      - name: Upload archive log on failure
        if: failure()
        uses: actions/upload-artifact@v4
        with:
          name: xcode-archive-log
          path: build/ios/archive.log

      - name: Zip xcresult bundles on failure
        if: failure()
        run: |
          ditto -c -k --sequesterRsrc --keepParent build/ios/ArchiveResult.xcresult build/ios/ArchiveResult.xcresult.zip || true
          ditto -c -k --sequesterRsrc --keepParent build/ios/ExportResult.xcresult build/ios/ExportResult.xcresult.zip || true

      - name: Upload xcresult bundles on failure
        if: failure()
        uses: actions/upload-artifact@v4
        with:
          name: xcode-result-bundles
          path: |
            build/ios/ArchiveResult.xcresult.zip
            build/ios/ExportResult.xcresult.zip

      - name: Export IPA (App Store)
        run: |
          cat > exportOptions.plist <<EOF
          <?xml version="1.0" encoding="UTF-8"?>
          <!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
          <plist version="1.0">
          <dict>
            <key>method</key><string>app-store</string>
            <key>teamID</key><string>$TEAM_ID</string>
            <key>signingCertificate</key><string>Apple Distribution</string>
            <key>signingStyle</key><string>manual</string>
            <key>provisioningProfiles</key>
            <dict>
              <key>$BUNDLE_ID</key><string>$PROFILE_NAME</string>
            </dict>
            <key>stripSwiftSymbols</key><true/>
            <key>compileBitcode</key><false/>
          </dict>
          </plist>
          EOF
          xcodebuild -exportArchive \
            -archivePath build/ios/Runner.xcarchive \
            -exportOptionsPlist exportOptions.plist \
            -exportPath build/ios/ipa \
            -resultBundlePath build/ios/ExportResult.xcresult

      - name: Upload IPA artifact
        uses: actions/upload-artifact@v4
        with:
          name: Runner-ipa
          path: build/ios/ipa/*.ipa

      - name: Install ASC key for Transporter
        run: |
          mkdir -p ~/.appstoreconnect/private_keys
          echo "${{ secrets.ASC_KEY_P8_BASE64 }}" | base64 --decode > ~/.appstoreconnect/private_keys/AuthKey_${{ secrets.ASC_KEY_ID }}.p8

      - name: Upload to TestFlight via Transporter
        env:
          ASC_KEY_ID: ${{ secrets.ASC_KEY_ID }}
          ASC_ISSUER_ID: ${{ secrets.ASC_ISSUER_ID }}
        run: |
          xcrun iTMSTransporter \
            -m upload \
            -apiKey "$ASC_KEY_ID" \
            -apiIssuer "$ASC_ISSUER_ID" \
            -assetFile build/ios/ipa/Runner.ipa \
            -v informational
