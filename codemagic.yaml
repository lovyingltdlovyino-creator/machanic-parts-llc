workflows:
  ios_app_store:
    name: iOS App Store
    instance_type: mac_mini_m1
    max_build_duration: 120
    environment:
      flutter: stable
      xcode: latest
      cocoapods: default
      # Create these groups in Codemagic UI and add the variables inside them
      groups:
        - supabase_env            # SUPABASE_URL, SUPABASE_ANON_KEY
        - app_store_connect       # APP_STORE_CONNECT_PRIVATE_KEY, APP_STORE_CONNECT_KEY_IDENTIFIER, APP_STORE_CONNECT_ISSUER_ID
        - revenuecat_env          # REVENUECAT_IOS_PUBLIC_SDK_KEY
        - supabse                 # fallback if group was misspelled in UI
        # Optionally: ios_signing  # If you prefer manual signing (CERT, CERT_PASSWORD, PROVISIONING_PROFILE)
      vars:
        BUNDLE_ID: com.mechanicpart.mechanicPart
        XCODE_WORKSPACE: ios/Runner.xcworkspace
        XCODE_SCHEME: Runner
        # Explicitly set the iOS deployment target
        IOS_DEPLOYMENT_TARGET: "13.0"
    triggering:
      events:
        - push
      branch_patterns:
        - pattern: main
          include: true
          source: true
      cancel_previous_builds: true
    scripts:
      - name: Flutter version
        script: flutter --version
      - name: Dependencies
        script: flutter pub get
      - name: Create .env from CI variables
        script: |
          echo "Creating .env for Flutter asset bundling"
          {
            [ -n "${SUPABASE_URL:-}" ] && echo "SUPABASE_URL=${SUPABASE_URL}";
            [ -n "${SUPABASE_ANON_KEY:-}" ] && echo "SUPABASE_ANON_KEY=${SUPABASE_ANON_KEY}";
            [ -n "${REVENUECAT_IOS_PUBLIC_SDK_KEY:-}" ] && echo "REVENUECAT_IOS_PUBLIC_SDK_KEY=${REVENUECAT_IOS_PUBLIC_SDK_KEY}";
          } > .env
          echo ".env created"
      - name: Generate launcher icons (idempotent)
        script: dart run flutter_launcher_icons
      - name: Generate native splash (idempotent)
        script: dart run flutter_native_splash:create
      - name: Verify required env vars (Supabase)
        script: |
          if [ -z "${SUPABASE_URL:-}" ] || [ -z "${SUPABASE_ANON_KEY:-}" ]; then
            echo "Missing SUPABASE_URL or SUPABASE_ANON_KEY"
            exit 1
          fi
          echo "SUPABASE_URL is set"
          echo "SUPABASE_ANON_KEY is set"
      # Automatic signing: fetch/create certs & profiles via App Store Connect, then import
      - name: Set up iOS code signing (fetch & import)
        script: |
          set -e
          keychain initialize
          KEYCHAIN_PATH=$(security default-keychain | tr -d '"')
          echo "Default keychain is: $KEYCHAIN_PATH"
          echo "Fetching signing files from App Store Connect for $BUNDLE_ID (IOS_APP_STORE)..."
          app-store-connect fetch-signing-files "$BUNDLE_ID" --type IOS_APP_STORE --create || echo "WARN: fetch-signing-files failed"
          echo "Importing certificates from Code signing to keychain..."
          keychain add-certificates || true
      - name: "Fallback: install signing assets from env (if provided)"
        script: |
          set -e
          CERT_TMP="$HOME/certificate.p12"
          PROFILE_DIR="$HOME/Library/MobileDevice/Provisioning Profiles"
          mkdir -p "$PROFILE_DIR"
          # Create and use a dedicated keychain for CI
          KEYCHAIN_PATH="$HOME/Library/Keychains/manual.keychain-db"
          KEYCHAIN_PASSWORD="${CM_KEYCHAIN_PASSWORD:-codemagic}"
          echo "Creating and unlocking manual keychain at: $KEYCHAIN_PATH"
          security create-keychain -p "$KEYCHAIN_PASSWORD" "$KEYCHAIN_PATH" || true
          security set-keychain-settings -lut 3600 "$KEYCHAIN_PATH"
          security unlock-keychain -p "$KEYCHAIN_PASSWORD" "$KEYCHAIN_PATH"
          security list-keychains -s "$KEYCHAIN_PATH"
          security default-keychain -s "$KEYCHAIN_PATH"
          if [ -n "${IOS_CERTIFICATE_P12:-}" ] && [ -n "${IOS_CERTIFICATE_PASSWORD:-}" ]; then
            echo "Decoding IOS_CERTIFICATE_P12 from env"
            printf %s "$IOS_CERTIFICATE_P12" | base64 --decode > "$CERT_TMP"
            echo "Importing certificate into $KEYCHAIN_PATH"
            security import "$CERT_TMP" -k "$KEYCHAIN_PATH" -P "$IOS_CERTIFICATE_PASSWORD" -A -t cert -f pkcs12
            # Allow codesign to access the key without interactive prompts
            security set-key-partition-list -S apple-tool:,apple:,codesign: -s -k "$KEYCHAIN_PASSWORD" "$KEYCHAIN_PATH"
            rm -f "$CERT_TMP"
          fi
          if [ -n "${IOS_PROVISIONING_PROFILE:-}" ]; then
            echo "Decoding IOS_PROVISIONING_PROFILE from env"
            echo "$IOS_PROVISIONING_PROFILE" | base64 --decode > "$PROFILE_DIR/Manual.mobileprovision"
          fi
      - name: Debug signing assets
        script: |
          echo "-- Code signing identities --"
          security find-identity -v -p codesigning || true
          echo "-- Provisioning profiles --"
          ls -al "$HOME/Library/MobileDevice/Provisioning Profiles" || true
          KEYCHAIN_PATH=$(security default-keychain | tr -d '"')
          echo "Using keychain: $KEYCHAIN_PATH"
          if [ -n "${IOS_CERTIFICATE_P12:-}" ]; then
            echo "IOS_CERTIFICATE_P12 is set (length: $(echo -n "$IOS_CERTIFICATE_P12" | wc -c))"
          else
            echo "IOS_CERTIFICATE_P12 is NOT set"
          fi
          if [ -n "${IOS_CERTIFICATE_PASSWORD:-}" ]; then
            echo "IOS_CERTIFICATE_PASSWORD is set"
          else
            echo "IOS_CERTIFICATE_PASSWORD is NOT set"
          fi
          # Fail early if Distribution identity is not present
          if ! security find-identity -v -p codesigning | grep -q "Apple Distribution"; then
            echo "ERROR: Missing 'Apple Distribution' signing identity with private key."
            echo "Ensure either Code signing certificates are added in Codemagic UI or IOS_CERTIFICATE_P12/IOS_CERTIFICATE_PASSWORD env vars are set."
            exit 1
          fi
      - name: Flutter build ios (no codesign)
        script: |
          # Make sure Podfile has correct deployment target
          sed -i '' "s/platform :ios, '.*'/platform :ios, '$IOS_DEPLOYMENT_TARGET'/g" ios/Podfile
          flutter clean
          flutter build ios --release --no-codesign \
            --dart-define SUPABASE_URL="$SUPABASE_URL" \
            --dart-define SUPABASE_ANON_KEY="$SUPABASE_ANON_KEY" \
            --dart-define REVENUECAT_IOS_PUBLIC_SDK_KEY="$REVENUECAT_IOS_PUBLIC_SDK_KEY"
      - name: Configure Xcode project with provisioning profiles
        script: |
          xcode-project use-profiles
      - name: Resolve provisioning profile UUID (force)
        script: |
          set -e
          PROFILE_DIR="$HOME/Library/MobileDevice/Provisioning Profiles"
          MATCH_NAME=""
          MATCH_UUID=""
          MATCH_TYPE=""
          echo "Ensuring provisioning profiles are installed in $PROFILE_DIR"
          if ! ls "$PROFILE_DIR"/*.mobileprovision 1>/dev/null 2>&1; then
            echo "No profiles found locally, trying to install from Code signing..."
            xcode-project use-profiles || true
            ls -al "$PROFILE_DIR" || true
          fi
          if ! ls "$PROFILE_DIR"/*.mobileprovision 1>/dev/null 2>&1; then
            if [ -n "${APP_STORE_CONNECT_ISSUER_ID:-}" ] && [ -n "${APP_STORE_CONNECT_KEY_IDENTIFIER:-}" ] && [ -n "${APP_STORE_CONNECT_PRIVATE_KEY:-}" ]; then
              echo "Attempting to fetch signing files from App Store Connect..."
              app-store-connect fetch-signing-files "$BUNDLE_ID" --type IOS_APP_STORE --create || true
              xcode-project use-profiles || true
            fi
          fi
          # Prefer App Store profiles: no ProvisionedDevices and get-task-allow=false
          for p in "$PROFILE_DIR"/*.mobileprovision; do
            [ -f "$p" ] || continue
            INFO=$(security cms -D -i "$p" 2>/dev/null || true)
            NAME=$(/usr/libexec/PlistBuddy -c 'Print :Name' /dev/stdin <<< "$INFO" 2>/dev/null || true)
            UUID=$(/usr/libexec/PlistBuddy -c 'Print :UUID' /dev/stdin <<< "$INFO" 2>/dev/null || true)
            APP_ID=$(/usr/libexec/PlistBuddy -c 'Print :Entitlements:application-identifier' /dev/stdin <<< "$INFO" 2>/dev/null || true)
            GET_TASK_ALLOW=$(/usr/libexec/PlistBuddy -c 'Print :Entitlements:get-task-allow' /dev/stdin <<< "$INFO" 2>/dev/null || echo "")
            HAS_DEVICES=$(/usr/libexec/PlistBuddy -c 'Print :ProvisionedDevices' /dev/stdin <<< "$INFO" 2>/dev/null && echo yes || echo no)
            PROFILE_TYPE="development"
            if [ "$HAS_DEVICES" = "no" ] && [ "${GET_TASK_ALLOW}" = "false" ]; then
              PROFILE_TYPE="app-store"
            fi
            if [ -n "$APP_ID" ] && [[ "$APP_ID" == "${APPLE_TEAM_ID:-}.$BUNDLE_ID" || "$APP_ID" == *".$BUNDLE_ID" ]]; then
              # Select the first app-store profile; otherwise remember a fallback
              if [ "$PROFILE_TYPE" = "app-store" ]; then
                MATCH_NAME="$NAME"; MATCH_UUID="$UUID"; MATCH_TYPE="$PROFILE_TYPE";
                echo "Matched App Store provisioning profile: name='$MATCH_NAME' uuid='$MATCH_UUID'"
                break
              elif [ -z "$MATCH_UUID" ]; then
                MATCH_NAME="$NAME"; MATCH_UUID="$UUID"; MATCH_TYPE="$PROFILE_TYPE";
              fi
            fi
          done
          if [ -z "$MATCH_UUID" ]; then
            echo "ERROR: No provisioning profile found for $BUNDLE_ID in $PROFILE_DIR. Upload an App Store profile or set IOS_PROVISIONING_PROFILE env."
            exit 1
          fi
          export PROFILE_UUID="$MATCH_UUID"
          export PROFILE_NAME="$MATCH_NAME"
          export PROFILE_SPECIFIER="$MATCH_NAME"
          echo "Using provisioning profile: $PROFILE_NAME ($PROFILE_UUID) type=$MATCH_TYPE"
          if [ -n "${CM_ENV:-}" ]; then
            echo "PROFILE_UUID=$PROFILE_UUID" >> "$CM_ENV"
            echo "PROFILE_NAME=$PROFILE_NAME" >> "$CM_ENV"
            echo "PROFILE_SPECIFIER=$PROFILE_SPECIFIER" >> "$CM_ENV"
          fi
      - name: Show Xcode signing build settings
        script: |
          set -e
          echo "--- Xcode Build Settings (signing-related) ---"
          xcodebuild -workspace "$XCODE_WORKSPACE" -scheme "$XCODE_SCHEME" -configuration Release -sdk iphoneos -destination "generic/platform=iOS" -showBuildSettings | egrep -i "^(\s*CODE_SIGN|\s*PROVISIONING_PROFILE|\s*PRODUCT_BUNDLE_IDENTIFIER|\s*DEVELOPMENT_TEAM)"
      - name: Build IPA with Xcode (manual signing, UUID)
        script: |
          # Strip injected export options envs and always provide our own file
          unset CM_EXPORT_OPTIONS || true
          unset EXPORT_OPTIONS_PLIST || true
          FALLBACK_PLIST="$HOME/export_options.plist"
          echo "Writing export options plist to $FALLBACK_PLIST"
          # Require UUID and map export to the profile name
          if [ -z "${PROFILE_UUID:-}" ]; then
            echo "ERROR: PROFILE_UUID is not set; cannot proceed with manual signing."
            exit 1
          fi
          EXPORT_NAME="${PROFILE_NAME:-${PROFILE_SPECIFIER:-AppStoreProfile}}"
          printf '%s\n' \
            '<?xml version="1.0" encoding="UTF-8"?>' \
            '<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">' \
            '<plist version="1.0">' \
            '<dict>' \
            '  <key>method</key>' \
            '  <string>app-store</string>' \
            '  <key>teamID</key>' \
            "  <string>${APPLE_TEAM_ID}</string>" \
            '  <key>signingStyle</key>' \
            '  <string>manual</string>' \
            '  <key>signingCertificate</key>' \
            '  <string>Apple Distribution</string>' \
            '  <key>provisioningProfiles</key>' \
            '  <dict>' \
            "    <key>$BUNDLE_ID</key>" \
            "    <string>$EXPORT_NAME</string>" \
            '  </dict>' \
            '  <key>uploadBitcode</key>' \
            '  <false/>' \
            '  <key>compileBitcode</key>' \
            '  <false/>' \
            '</dict>' \
            '</plist>' > "$FALLBACK_PLIST"
          # Archive with manual signing using UUID
          ARCHIVE_PATH="$PWD/build/ios/xcarchive/Runner.xcarchive"
          mkdir -p "$(dirname "$ARCHIVE_PATH")" build/ios/ipa
          # Build argument array to avoid quoting issues
          ARGS=(
            CODE_SIGN_STYLE=Manual
            "PROVISIONING_PROFILE=$PROFILE_UUID"
            "PROVISIONING_PROFILE_SPECIFIER=$PROFILE_SPECIFIER"
            "PRODUCT_BUNDLE_IDENTIFIER=$BUNDLE_ID"
            "CODE_SIGN_IDENTITY=Apple Distribution"
            CODE_SIGNING_REQUIRED=YES
            CODE_SIGNING_ALLOWED=YES
          )
          if [ -n "${APPLE_TEAM_ID:-}" ]; then ARGS+=("DEVELOPMENT_TEAM=$APPLE_TEAM_ID"); fi
          echo "Archiving with: ${ARGS[*]}"
          xcodebuild -workspace "$XCODE_WORKSPACE" -scheme "$XCODE_SCHEME" -configuration Release -sdk iphoneos -destination "generic/platform=iOS" -allowProvisioningUpdates -archivePath "$ARCHIVE_PATH" archive "${ARGS[@]}"
          echo "Inspecting archive signing metadata..."
          /usr/libexec/PlistBuddy -c "Print :ApplicationProperties:Team" "$ARCHIVE_PATH/Info.plist" 2>/dev/null || echo "Team: <none>"
          /usr/libexec/PlistBuddy -c "Print :ApplicationProperties:SigningIdentity" "$ARCHIVE_PATH/Info.plist" 2>/dev/null || echo "SigningIdentity: <none>"
          APP_PATH="$ARCHIVE_PATH/Products/Applications/Runner.app"
          if [ -d "$APP_PATH" ]; then
            codesign -dv --verbose=4 "$APP_PATH" 2>&1 | egrep -i "(TeamIdentifier|Authority|Identifier|TeamName)" || true
          fi
          echo "Exporting IPA..."
          xcodebuild -exportArchive -archivePath "$ARCHIVE_PATH" -exportOptionsPlist "$FALLBACK_PLIST" -exportPath build/ios/ipa -allowProvisioningUpdates
          
          # Verify IPA was created
          if [ ! -f build/ios/ipa/*.ipa ]; then
            echo "Error: IPA file not generated. Check export log above."
            exit 1
          fi
          
          echo "IPA Successfully created at: $(ls build/ios/ipa/*.ipa)"
    artifacts:
      - build/ios/ipa/*.ipa
      - build/ios/xcarchive/*.xcarchive
    publishing:
      app_store_connect:
        # Provide these as secure env vars in group: app_store_connect
        api_key: $APP_STORE_CONNECT_PRIVATE_KEY
        key_id: $APP_STORE_CONNECT_KEY_IDENTIFIER
        issuer_id: $APP_STORE_CONNECT_ISSUER_ID
        submit_to_testflight: true
        beta_groups: ["Testers"]

